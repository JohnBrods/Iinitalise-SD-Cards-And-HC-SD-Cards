                                                    /*Anyone is free to copy, modify, publish, use, compile or
                                                    distribute this software, either in source code form or as a compiled
                                                    binary, for non-commercial use only. (i.e. YOU MAY NOT SELL IT)

                                                    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                                                    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                                                    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                                                    IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
                                                    OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
                                                    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
                                                    OTHER DEALINGS IN THE SOFTWARE.*/
                                                    //This C file contains my everything to get a Seiko Epson S1D13517-
                                                    //Display Controller to work with a 24 bit colour LCD, 800x480 LCD.
                                                    //Initialise_SDCARD & Read pictures, no library required. It will load 13-
                                                    // pictures into the SDRAM then display them from the memory.
                                                    //Demonstrated on YouTube 17/Oct/21.
                                                    //Another First of it's kind on YouTube.
                                                    //Improved 'write text' too.
                                                    //It will initialise a FAT16 and a FAT32 ni library except for SPI.
#include <stdint.h>

//Started Epson Programming 18:30 11/November 2022
//updated 31 / 01 / 2026

//==============================================================

//FontName : Tahoma24x27
//FontSize : 24 x 27

const unsigned char Letter_Font[] = {

   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 32 SPACE
   0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,
   0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,
   0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x00,
   0x38,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 33 !
   0x00,0x00,0x00,0x38,0x07,0x00,0x38,0x07,0x00,0x38,0x07,0x00,0x38,0x07,0x00,0x38,0x07,0x00,0x38,0x07,
   0x00,0x38,0x07,0x00,0x10,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 34 "
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8C,0x01,0x00,0x8C,0x01,0x00,0xC6,0x00,0x00,0xC6,0x00,0x00,0xC6,
   0x00,0x00,0xC6,0x00,0xE0,0xFF,0x07,0xE0,0xFF,0x07,0x00,0x63,0x00,0x00,0x63,0x00,0x80,0x31,0x00,0x80,
   0x31,0x00,0x80,0x31,0x00,0xF8,0xFF,0x01,0xF8,0xFF,0x01,0xC0,0x18,0x00,0xC0,0x18,0x00,0xC0,0x18,0x00,
   0x60,0x0C,0x00,0x60,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 35 #
   0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x80,0x3F,0x00,0xE0,0x7F,
   0x00,0x70,0x66,0x00,0x38,0x46,0x00,0x38,0x06,0x00,0x38,0x06,0x00,0x78,0x06,0x00,0xF0,0x07,0x00,0xE0,
   0x3F,0x00,0x00,0x7E,0x00,0x00,0xF6,0x00,0x00,0xE6,0x00,0x00,0xE6,0x00,0x08,0xE6,0x00,0x38,0x76,0x00,
   0xF8,0x3F,0x00,0xE0,0x1F,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00, // Code ASCII 36 $
   0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x00,0x03,0xFE,0x80,0x01,0xC6,0x80,0x01,0x83,0xC1,0x00,0x83,0xC1,
   0x00,0x83,0x61,0x00,0x83,0x61,0x00,0x83,0x31,0x00,0x83,0x31,0x3E,0xC6,0x18,0x7F,0xFE,0x18,0x63,0x7C,
   0x8C,0xC1,0x00,0x8C,0xC1,0x00,0x86,0xC1,0x00,0x86,0xC1,0x00,0x83,0xC1,0x00,0x83,0xC1,0x80,0x01,0x63,
   0x80,0x01,0x7F,0xC0,0x00,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 37 %
   0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x0F,0x00,0xE0,0x1F,0x00,0xE0,0x3C,0x00,0x70,0x38,0x00,0x70,0x38,
   0x00,0x70,0x38,0x00,0xF0,0x18,0x00,0xE0,0x1D,0x00,0xC0,0x8F,0x03,0xC0,0x87,0x03,0x60,0x8F,0x03,0x70,
   0x9E,0x03,0x38,0xBC,0x03,0x38,0xF8,0x01,0x38,0xF0,0x01,0x38,0xE0,0x01,0x78,0xE0,0x03,0xF0,0xF0,0x07,
   0xE0,0x3F,0x0F,0xC0,0x0F,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 38 &
   0x00,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,
   0x00,0x38,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 39 '
   0x00,0x00,0x00,0x00,0x07,0x00,0x80,0x03,0x00,0xC0,0x01,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0x70,0x00,
   0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x78,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,
   0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x78,0x00,0x00,0x70,0x00,0x00,
   0x70,0x00,0x00,0x70,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xC0,0x01,0x00,0x80,0x03,0x00,0x00,0x07,0x00, // Code ASCII 40 (
   0x00,0x00,0x00,0x38,0x00,0x00,0x70,0x00,0x00,0xE0,0x00,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0x80,0x03,
   0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,
   0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x80,0x07,0x00,0x80,0x03,0x00,
   0x80,0x03,0x00,0x80,0x03,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xE0,0x00,0x00,0x70,0x00,0x00,0x38,0x00,0x00, // Code ASCII 41 )
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x20,0x46,0x00,0x70,0xE6,0x00,0xC0,0x3F,0x00,0x00,0x0F,0x00,0x00,
   0x0F,0x00,0xC0,0x3F,0x00,0x70,0xE6,0x00,0x20,0x46,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 42 *
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x00,0x0C,
   0x00,0x00,0x0C,0x00,0x00,0x0C,0x00,0x00,0x0C,0x00,0x00,0x0C,0x00,0x00,0x0C,0x00,0xF8,0xFF,0x07,0xF8,
   0xFF,0x07,0x00,0x0C,0x00,0x00,0x0C,0x00,0x00,0x0C,0x00,0x00,0x0C,0x00,0x00,0x0C,0x00,0x00,0x0C,0x00,
   0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 43 +
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x01,0x00,0xE0,0x00,0x00,
   0xE0,0x00,0x00,0x60,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x30,0x00,0x00,0x38,0x00,0x00,0x18,0x00,0x00, // Code ASCII 44 ,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x07,0x00,0xF8,
   0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 45 -
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x78,0x00,0x00,
   0x78,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 46 .
   0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x1C,0x00,0x00,0x0C,0x00,0x00,0x0C,0x00,0x00,0x0C,0x00,0x00,0x06,
   0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x80,0x01,0x00,0x80,
   0x01,0x00,0x80,0x01,0x00,0xC0,0x00,0x00,0xC0,0x00,0x00,0xC0,0x00,0x00,0x60,0x00,0x00,0x60,0x00,0x00,
   0x60,0x00,0x00,0x30,0x00,0x00,0x30,0x00,0x00,0x30,0x00,0x00,0x38,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00, // Code ASCII 47
   0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x0F,0x00,0xE0,0x3F,0x00,0xE0,0x38,0x00,0x70,0x70,0x00,0x70,0x70,
   0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,
   0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x70,0x70,0x00,0x70,0x70,0x00,0xE0,0x38,0x00,
   0xE0,0x3F,0x00,0x80,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 48 0
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x80,0x03,0x00,0xC0,0x03,0x00,0xF8,0x03,0x00,0xF8,0x03,
   0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,
   0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,
   0xF8,0x3F,0x00,0xF8,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 49 1
   0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x07,0x00,0xF8,0x0F,0x00,0x38,0x1C,0x00,0x08,0x38,0x00,0x00,0x38,
   0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x0E,0x00,0x00,
   0x0F,0x00,0x80,0x07,0x00,0x80,0x03,0x00,0xC0,0x01,0x00,0xE0,0x00,0x00,0x70,0x00,0x00,0x38,0x00,0x00,
   0xF8,0x7F,0x00,0xF8,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 50 2
   0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x0F,0x00,0xF0,0x3F,0x00,0x70,0x78,0x00,0x10,0x70,0x00,0x00,0x70,
   0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x3C,0x00,0x80,0x0F,0x00,0x80,0x0F,0x00,0x00,0x38,0x00,0x00,
   0x30,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x08,0x38,0x00,0x38,0x3C,0x00,
   0xF8,0x1F,0x00,0xE0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 51 3
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x3C,0x00,0x00,0x3E,0x00,0x00,0x3B,0x00,0x00,0x3B,
   0x00,0x80,0x39,0x00,0xC0,0x38,0x00,0x60,0x38,0x00,0x30,0x38,0x00,0x30,0x38,0x00,0x18,0x38,0x00,0xF8,
   0xFF,0x00,0xF8,0xFF,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,
   0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 52 4
   0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x7F,0x00,0xF0,0x7F,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,
   0x00,0x70,0x00,0x00,0x70,0x00,0x00,0xF0,0x0F,0x00,0xF0,0x1F,0x00,0x00,0x3C,0x00,0x00,0x78,0x00,0x00,
   0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x08,0x38,0x00,0x38,0x3C,0x00,
   0xF8,0x1F,0x00,0xE0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 53 5
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x00,0x80,0x3F,0x00,0xC0,0x21,0x00,0xE0,0x00,0x00,0x70,0x00,
   0x00,0x70,0x00,0x00,0x30,0x00,0x00,0x38,0x1F,0x00,0xF8,0x3F,0x00,0x78,0x78,0x00,0x38,0xF0,0x00,0x38,
   0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x70,0xE0,0x00,0x70,0x70,0x00,0xE0,0x78,0x00,
   0xE0,0x3F,0x00,0x80,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 54 6
   0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x7F,0x00,0xF8,0x7F,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x38,
   0x00,0x00,0x38,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x07,0x00,0x00,
   0x07,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xE0,0x00,0x00,
   0xE0,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 55 7
   0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x1F,0x00,0xE0,0x3F,0x00,0x70,0x70,0x00,0x38,0xE0,0x00,0x38,0xE0,
   0x00,0x38,0xE0,0x00,0x78,0xE0,0x00,0xF0,0x70,0x00,0xE0,0x3B,0x00,0xC0,0x1F,0x00,0x70,0x3E,0x00,0x70,
   0x78,0x00,0x38,0xF0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x78,0xF0,0x00,0xF0,0x78,0x00,
   0xE0,0x3F,0x00,0x80,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 56 8
   0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x0F,0x00,0xE0,0x3F,0x00,0xF0,0x38,0x00,0x70,0x70,0x00,0x38,0x70,
   0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x78,0xE0,0x00,0xF0,0xF0,0x00,0xE0,
   0xFF,0x00,0xC0,0xE7,0x00,0x00,0x60,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x38,0x00,0x20,0x1C,0x00,
   0xE0,0x0F,0x00,0xE0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 57 9
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,
   0x38,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 58 :
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x01,0x00,0xE0,0x00,0x00,
   0xE0,0x00,0x00,0x60,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x30,0x00,0x00,0x38,0x00,0x00,0x18,0x00,0x00, // Code ASCII 59
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x01,0x00,0xC0,0x01,0x00,0xF0,0x00,0x00,0x3C,0x00,0x00,0x0F,0x00,0xC0,0x03,0x00,0xF0,0x00,0x00,0x38,
   0x00,0x00,0xF0,0x00,0x00,0xC0,0x03,0x00,0x00,0x0F,0x00,0x00,0x3C,0x00,0x00,0xF0,0x00,0x00,0xC0,0x01,
   0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 60
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0x03,0xF8,0xFF,0x03,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0x03,0xF8,0xFF,0x03,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 61 =
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,
   0x00,0x38,0x00,0x00,0xF0,0x00,0x00,0xC0,0x03,0x00,0x00,0x0F,0x00,0x00,0x3C,0x00,0x00,0xF0,0x00,0x00,
   0xC0,0x01,0x00,0xF0,0x00,0x00,0x3C,0x00,0x00,0x0F,0x00,0xC0,0x03,0x00,0xF0,0x00,0x00,0x38,0x00,0x00,
   0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 62 >
   0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x07,0x00,0xF8,0x1F,0x00,0x18,0x1C,0x00,0x08,0x38,0x00,0x00,0x38,
   0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x1C,0x00,0x00,0x1E,0x00,0x00,0x0F,0x00,0x80,0x07,0x00,0xC0,
   0x01,0x00,0xC0,0x00,0x00,0xC0,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,
   0xC0,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 63 ?
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x01,0x00,0xFF,0x07,0x80,0x07,0x1E,0xC0,0x01,0x38,0xE0,0x00,
   0x30,0x60,0xF8,0x63,0x30,0xFC,0x63,0x30,0x0E,0xE3,0x18,0x07,0xC3,0x18,0x03,0xC3,0x18,0x03,0xC3,0x18,
   0x03,0xC3,0x18,0x03,0xC3,0x18,0x03,0xC3,0x18,0x03,0xC3,0x30,0x86,0x63,0x30,0xFE,0x7F,0x70,0x78,0x3F,
   0xE0,0x00,0x00,0xC0,0x01,0x00,0x80,0x07,0x02,0x00,0xFF,0x03,0x00,0xFC,0x03,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 64 @
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x00,0x00,0x1E,0x00,0x00,0x1E,0x00,0x00,0x3F,0x00,0x00,0x3F,
   0x00,0x00,0x3F,0x00,0x80,0x73,0x00,0x80,0x73,0x00,0x80,0x73,0x00,0xC0,0xE1,0x00,0xC0,0xE1,0x00,0xC0,
   0xE1,0x00,0xE0,0xFF,0x01,0xE0,0xFF,0x01,0xE0,0xC0,0x01,0xF0,0xC0,0x03,0x70,0x80,0x03,0x70,0x80,0x03,
   0x78,0x80,0x07,0x38,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 65 UPPER CASE A
   0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x0F,0x00,0xF8,0x3F,0x00,0x38,0x78,0x00,0x38,0x70,0x00,0x38,0x70,
   0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x38,0x00,0xF8,0x1F,0x00,0xF8,0x3F,0x00,0x38,0x70,0x00,0x38,
   0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0x70,0x00,0x38,0x78,0x00,
   0xF8,0x3F,0x00,0xF8,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 66 UPPER CASE B
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x00,0x80,0xFF,0x01,0xE0,0xC1,0x01,0xE0,0x80,0x01,0x70,0x00,
   0x01,0x70,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,
   0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x01,0xE0,0x80,0x01,0xE0,0xC1,0x01,
   0xC0,0xFF,0x01,0x00,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 67 UPPER CASE C
   0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x0F,0x00,0xF8,0x3F,0x00,0x38,0x78,0x00,0x38,0xE0,0x00,0x38,0xC0,
   0x01,0x38,0xC0,0x01,0x38,0x80,0x03,0x38,0x80,0x03,0x38,0x80,0x03,0x38,0x80,0x03,0x38,0x80,0x03,0x38,
   0x80,0x03,0x38,0x80,0x03,0x38,0x80,0x03,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xE0,0x00,0x38,0x78,0x00,
   0xF8,0x3F,0x00,0xF8,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 68 UPPER CASE D
   0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x7F,0x00,0xF8,0x7F,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,
   0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0xF8,0x3F,0x00,0xF8,0x3F,0x00,0x38,0x00,0x00,0x38,
   0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,
   0xF8,0x7F,0x00,0xF8,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 69 UPPER CASE E
   0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x7F,0x00,0xF8,0x7F,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,
   0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0xF8,0x7F,0x00,0xF8,0x7F,0x00,0x38,0x00,0x00,0x38,
   0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,
   0x38,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 70 UPPER CASE F
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x80,0xFF,0x03,0xC0,0x83,0x07,0xE0,0x00,0x06,0x70,0x00,
   0x04,0x70,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0xF0,0x07,0x38,
   0xF0,0x07,0x38,0x00,0x07,0x38,0x00,0x07,0x70,0x00,0x07,0x70,0x00,0x07,0xE0,0x00,0x07,0xC0,0x03,0x07,
   0x80,0xFF,0x07,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 71 UPPER CASE G
   0x00,0x00,0x00,0x00,0x00,0x00,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,
   0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0xF8,0xFF,0x01,0xF8,0xFF,0x01,0x38,0xC0,0x01,0x38,
   0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,
   0x38,0xC0,0x01,0x38,0xC0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 72 UPPER CASE H
   0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x0F,0x00,0xF8,0x0F,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xC0,0x01,
   0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xC0,
   0x01,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,
   0xF8,0x0F,0x00,0xF8,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 73 UPPER CASE I
   0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x0F,0x00,0xE0,0x0F,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,
   0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,
   0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x08,0x07,0x00,
   0xF8,0x07,0x00,0xF8,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 74 UPPER CASE J
   0x00,0x00,0x00,0x00,0x00,0x00,0x38,0xE0,0x01,0x38,0xF0,0x00,0x38,0x78,0x00,0x38,0x3C,0x00,0x38,0x1E,
   0x00,0x38,0x0F,0x00,0xB8,0x07,0x00,0xB8,0x03,0x00,0xF8,0x01,0x00,0xF8,0x01,0x00,0xF8,0x03,0x00,0xB8,
   0x07,0x00,0x38,0x0F,0x00,0x38,0x0E,0x00,0x38,0x1E,0x00,0x38,0x3C,0x00,0x38,0x38,0x00,0x38,0x70,0x00,
   0x38,0xF0,0x00,0x38,0xE0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 75  UPPER CASE K
   0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,
   0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,
   0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,
   0xF8,0x3F,0x00,0xF8,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 76 UPPER CASE L
   0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x0F,0xF8,0x80,0x0F,0xF8,0x80,0x0F,0xF8,0x81,0x0F,0xB8,0xC1,
   0x0E,0xB8,0xC1,0x0E,0x38,0x63,0x0E,0x38,0x63,0x0E,0x38,0x67,0x0E,0x38,0x36,0x0E,0x38,0x3E,0x0E,0x38,
   0x1C,0x0E,0x38,0x1C,0x0E,0x38,0x08,0x0E,0x38,0x00,0x0E,0x38,0x00,0x0E,0x38,0x00,0x0E,0x38,0x00,0x0E,
   0x38,0x00,0x0E,0x38,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 77 UPPER CASE M
   0x00,0x00,0x00,0x00,0x00,0x00,0x78,0xC0,0x01,0xF8,0xC0,0x01,0xF8,0xC0,0x01,0xF8,0xC1,0x01,0xB8,0xC1,
   0x01,0xB8,0xC3,0x01,0x38,0xC3,0x01,0x38,0xC3,0x01,0x38,0xC6,0x01,0x38,0xC6,0x01,0x38,0xCE,0x01,0x38,
   0xCC,0x01,0x38,0xDC,0x01,0x38,0xD8,0x01,0x38,0xD8,0x01,0x38,0xF0,0x01,0x38,0xF0,0x01,0x38,0xF0,0x01,
   0x38,0xE0,0x01,0x38,0xE0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 78 UPPER CASE N
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x80,0xFF,0x00,0xE0,0xC1,0x03,0xE0,0x80,0x03,0x70,0x00,
   0x07,0x70,0x00,0x07,0x38,0x00,0x0E,0x38,0x00,0x0E,0x38,0x00,0x0E,0x38,0x00,0x0E,0x38,0x00,0x0E,0x38,
   0x00,0x0E,0x38,0x00,0x0E,0x38,0x00,0x0E,0x70,0x00,0x07,0x70,0x00,0x07,0xE0,0x80,0x03,0xE0,0xC1,0x03,
   0xC0,0xFF,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 79 UPPER CASE 0
   0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x0F,0x00,0xF8,0x3F,0x00,0x38,0x78,0x00,0x38,0x70,0x00,0x38,0xE0,
   0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0x70,0x00,0x38,0x78,0x00,0xF8,
   0x3F,0x00,0xF8,0x0F,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,
   0x38,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 80 UPPER CASE P
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x80,0xFF,0x00,0xE0,0xC1,0x03,0xE0,0x80,0x03,0x70,0x00,
   0x07,0x70,0x00,0x07,0x38,0x00,0x0E,0x38,0x00,0x0E,0x38,0x00,0x0E,0x38,0x00,0x0E,0x38,0x00,0x0E,0x38,
   0x00,0x0E,0x38,0x00,0x0E,0x38,0x00,0x0E,0x70,0x00,0x07,0x70,0x00,0x07,0xE0,0x80,0x03,0xE0,0xC1,0x03,
   0x80,0xFF,0x01,0x00,0x7F,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0xE0,0x00,0x00,0xE0,0x0F,0x00,0x80,0x0F, // Code ASCII 81 UPPER CASE Q
   0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x0F,0x00,0xF8,0x1F,0x00,0x38,0x38,0x00,0x38,0x70,0x00,0x38,0x70,
   0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x38,0x00,0x38,0x3C,0x00,0xF8,0x1F,0x00,0xF8,
   0x07,0x00,0x38,0x0F,0x00,0x38,0x1E,0x00,0x38,0x3C,0x00,0x38,0x38,0x00,0x38,0x78,0x00,0x38,0xF0,0x00,
   0x38,0xE0,0x01,0x38,0xC0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 82 UPPER CASE R
   0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x1F,0x00,0xE0,0x7F,0x00,0xF0,0x70,0x00,0x38,0x40,0x00,0x38,0x00,
   0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x78,0x00,0x00,0xF0,0x01,0x00,0xE0,0x1F,0x00,0x80,0x3F,0x00,0x00,
   0x78,0x00,0x00,0xF0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x08,0xE0,0x00,0x18,0x70,0x00,0x78,0x78,0x00,
   0xF8,0x3F,0x00,0xC0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 83 UPPER CASE S
   0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0x0F,0xF8,0xFF,0x0F,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,
   0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,
   0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,
   0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 84 UPPER CASE T
   0x00,0x00,0x00,0x00,0x00,0x00,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,
   0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,
   0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x38,0xC0,0x01,0x70,0xE0,0x00,0xF0,0xF0,0x00,
   0xE0,0x7F,0x00,0x80,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 85 UPPER CASE U
   0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x07,0x78,0x80,0x07,0x70,0x80,0x03,0x70,0x80,0x03,0xF0,0xC0,
   0x03,0xE0,0xC0,0x01,0xE0,0xC0,0x01,0xE0,0xE1,0x01,0xC0,0xE1,0x00,0xC0,0xE1,0x00,0xC0,0xF3,0x00,0x80,
   0x73,0x00,0x80,0x73,0x00,0x80,0x73,0x00,0x00,0x3F,0x00,0x00,0x3F,0x00,0x00,0x3F,0x00,0x00,0x1E,0x00,
   0x00,0x1E,0x00,0x00,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 86 UPPER CASE V
   0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x18,0xE0,0x07,0x3C,0xE0,0x0E,0x3C,0x70,0x0E,0x3C,0x70,0x0E,0x3C,
   0x70,0x0E,0x76,0x70,0x1C,0x66,0x38,0x1C,0x66,0x38,0x1C,0x66,0x38,0x1C,0xE3,0x38,0x38,0xC3,0x1C,0x38,
   0xC3,0x1C,0x38,0xC3,0x1C,0xB8,0xC1,0x1D,0xF0,0x81,0x0F,0xF0,0x81,0x0F,0xF0,0x81,0x0F,0xF0,0x81,0x0F,
   0xE0,0x00,0x07,0xE0,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 87 UPPER CASE W
   0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x07,0x70,0x80,0x03,0xE0,0xC0,0x01,0xE0,0xC0,0x01,0xC0,0xE1,
   0x00,0x80,0x73,0x00,0x80,0x73,0x00,0x00,0x3F,0x00,0x00,0x1F,0x00,0x00,0x1E,0x00,0x00,0x1E,0x00,0x00,
   0x1F,0x00,0x00,0x3F,0x00,0x80,0x73,0x00,0x80,0x73,0x00,0xC0,0xE1,0x00,0xE0,0xC0,0x01,0xE0,0xC0,0x01,
   0x70,0x80,0x03,0x38,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 88 UPPER CASE X
   0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x0F,0x70,0x00,0x07,0xE0,0x80,0x03,0xE0,0xC1,0x03,0xC0,0xC1,
   0x01,0xC0,0xE3,0x01,0x80,0xF3,0x00,0x00,0x77,0x00,0x00,0x7F,0x00,0x00,0x3E,0x00,0x00,0x1E,0x00,0x00,
   0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,
   0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 89 UPPER CASE Y
   0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0x00,0xF8,0xFF,0x00,0x00,0xE0,0x00,0x00,0x70,0x00,0x00,0x38,
   0x00,0x00,0x38,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x0E,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x80,
   0x03,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0x70,0x00,0x00,0x38,0x00,0x00,
   0xF8,0xFF,0x00,0xF8,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 90 UPPER CASE Z
   0x00,0x00,0x00,0xF8,0x03,0x00,0xF8,0x03,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,
   0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,
   0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,
   0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0xF8,0x03,0x00,0xF8,0x03,0x00, // Code ASCII 91 [
   0x00,0x00,0x00,0x18,0x00,0x00,0x38,0x00,0x00,0x30,0x00,0x00,0x30,0x00,0x00,0x70,0x00,0x00,0x60,0x00,
   0x00,0x60,0x00,0x00,0x60,0x00,0x00,0xC0,0x00,0x00,0xC0,0x00,0x00,0xC0,0x00,0x00,0x80,0x01,0x00,0x80,
   0x01,0x00,0x80,0x01,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x06,0x00,0x00,0x06,0x00,
   0x00,0x06,0x00,0x00,0x0E,0x00,0x00,0x0C,0x00,0x00,0x0C,0x00,0x00,0x1C,0x00,0x00,0x18,0x00,0x00,0x00,0x00, // Code ASCII 92
   0x00,0x00,0x00,0xF8,0x03,0x00,0xF8,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,
   0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,
   0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,
   0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0xF8,0x03,0x00,0xF8,0x03,0x00, // Code ASCII 93 ]
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x00,0x1E,0x00,0x00,0x1E,0x00,0x00,0x33,0x00,0x80,0x61,
   0x00,0x80,0x61,0x00,0xC0,0xC0,0x00,0xE0,0x80,0x01,0x60,0x80,0x01,0x30,0x00,0x03,0x38,0x00,0x07,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 94 ^
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0x03,0xF8,0xFF,0x03,0x00,0x00,0x00, // Code ASCII 95 _
   0x78,0x00,0x00,0x70,0x00,0x00,0xE0,0x00,0x00,0xC0,0x00,0x00,0xC0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 96 '
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0xE0,0x07,0x00,0xF0,0x1F,0x00,0x10,0x3C,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x80,0x3F,0x00,0xE0,
   0x3F,0x00,0xF0,0x38,0x00,0x78,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x78,0x3C,0x00,
   0xF0,0x3B,0x00,0xE0,0x39,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 97 LOWER CASE A
   0x00,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,
   0x00,0x38,0x0F,0x00,0xF8,0x1F,0x00,0xF8,0x38,0x00,0x38,0x38,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,
   0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x38,0x00,0x78,0x3C,0x00,
   0xF8,0x1F,0x00,0xB8,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 98 LOWER CASE B
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x80,0x0F,0x00,0xE0,0x1F,0x00,0xF0,0x18,0x00,0x70,0x10,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,
   0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x70,0x10,0x00,0xF0,0x18,0x00,
   0xE0,0x1F,0x00,0x80,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 99 LOWER CASE C
   0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,
   0x00,0x80,0x77,0x00,0xE0,0x7F,0x00,0xF0,0x78,0x00,0x70,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,
   0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x70,0x70,0x00,0x70,0x7C,0x00,
   0xE0,0x7F,0x00,0xC0,0x73,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 100 LOWER CASE D
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x80,0x0F,0x00,0xE0,0x1F,0x00,0xF0,0x38,0x00,0x70,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0xF8,
   0x7F,0x00,0xF8,0x7F,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x70,0x40,0x00,0xF0,0x60,0x00,
   0xE0,0x7F,0x00,0x80,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 101 LOWER CASE E
   0x00,0x00,0x00,0x80,0x0F,0x00,0xC0,0x0F,0x00,0xC0,0x01,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,
   0x00,0xF8,0x07,0x00,0xF8,0x07,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,
   0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,
   0xE0,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 102 LOWER CASE F
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x80,0x77,0x00,0xE0,0x7F,0x00,0xF0,0x78,0x00,0x70,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,
   0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x70,0x70,0x00,0x70,0x78,0x00,
   0xE0,0x7F,0x00,0xC0,0x73,0x00,0x00,0x70,0x00,0x00,0x30,0x00,0x10,0x38,0x00,0xF0,0x1F,0x00,0xF0,0x07,0x00, // Code ASCII 103 LOWER CASE G
   0x00,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,
   0x00,0x38,0x0F,0x00,0xB8,0x1F,0x00,0x78,0x3C,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,
   0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,
   0x38,0x38,0x00,0x38,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 104 LOWER CASE H
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,
   0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,
   0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 105 LOWER CASE I
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0xC0,0x07,0x00,0xC0,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,
   0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,
   0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x80,0x07,0x00,0xE0,0x03,0x00,0xE0,0x00,0x00, // Code ASCII 106 LOWER CASE J
   0x00,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,
   0x00,0x38,0x3C,0x00,0x38,0x1E,0x00,0x38,0x0E,0x00,0x38,0x07,0x00,0xB8,0x03,0x00,0xF8,0x01,0x00,0xF8,
   0x01,0x00,0xF8,0x03,0x00,0xB8,0x03,0x00,0x38,0x07,0x00,0x38,0x0F,0x00,0x38,0x0E,0x00,0x38,0x1C,0x00,
   0x38,0x3C,0x00,0x38,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 107 LOWER CASE K
   0x00,0x00,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,
   0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,
   0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,
   0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 108 LOWER CASE L
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0xCE,0xC3,0x03,0xEE,0xE7,0x07,0x3E,0x3F,0x0F,0x1E,0x1E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
   0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
   0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 109 LOWER CASE M
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x38,0x0F,0x00,0xB8,0x1F,0x00,0x78,0x3C,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,
   0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,
   0x38,0x38,0x00,0x38,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 110  LOWER CASE N
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x80,0x0F,0x00,0xE0,0x3F,0x00,0xF0,0x78,0x00,0x70,0x70,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,
   0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x38,0xE0,0x00,0x70,0x70,0x00,0xF0,0x78,0x00,
   0xE0,0x3F,0x00,0x80,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 111 LOWER CASE O
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x38,0x0F,0x00,0xF8,0x1F,0x00,0x78,0x38,0x00,0x38,0x38,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,
   0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x38,0x00,0x78,0x3C,0x00,
   0xF8,0x1F,0x00,0xB8,0x0F,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00, // Code ASCII 112 LOWER CASE P
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x80,0x77,0x00,0xE0,0x7F,0x00,0xF0,0x78,0x00,0x70,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,
   0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x38,0x70,0x00,0x70,0x70,0x00,0x70,0x78,0x00,
   0xE0,0x7F,0x00,0xC0,0x73,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00, // Code ASCII 113 LOWER CASE Q
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x38,0x07,0x00,0xB8,0x07,0x00,0xF8,0x07,0x00,0xF8,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,
   0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,
   0x38,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 114 LOWER CASE R
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0xE0,0x07,0x00,0xF0,0x0F,0x00,0x78,0x0C,0x00,0x38,0x08,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0xF8,
   0x01,0x00,0xF0,0x0F,0x00,0xC0,0x1F,0x00,0x00,0x1E,0x00,0x00,0x1C,0x00,0x08,0x1C,0x00,0x18,0x1E,0x00,
   0xF8,0x0F,0x00,0xE0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 115 LOWER CASE S
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,
   0x00,0xF8,0x0F,0x00,0xF8,0x0F,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,
   0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0x01,0x00,
   0xC0,0x0F,0x00,0x80,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 116 LOWER CASE T
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,
   0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x3C,0x00,0x78,0x3E,0x00,
   0xF0,0x3B,0x00,0xE0,0x39,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 117 LOWER CASE U
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x38,0xE0,0x00,0x70,0x70,0x00,0x70,0x70,0x00,0x70,0x70,0x00,0xE0,0x38,0x00,0xE0,0x38,0x00,0xE0,
   0x38,0x00,0xC0,0x1D,0x00,0xC0,0x1D,0x00,0xC0,0x1D,0x00,0x80,0x0F,0x00,0x80,0x0F,0x00,0x80,0x07,0x00,
   0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 118 LOWER CASE V
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x0E,0x0C,0x1C,0x0E,0x1C,0x1C,0x1C,0x1E,0x0E,0x1C,0x1E,0x0E,0x1C,0x3E,0x0E,0x1C,0x33,0x0E,0x18,
   0x33,0x06,0x38,0x73,0x06,0xB8,0x61,0x07,0xB8,0x61,0x07,0xB0,0xE1,0x03,0xF0,0xC0,0x03,0xF0,0xC0,0x03,
   0xE0,0xC0,0x03,0x60,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 119 LOWER CASE W
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x38,0xE0,0x00,0x70,0x70,0x00,0xE0,0x38,0x00,0xE0,0x38,0x00,0xC0,0x1D,0x00,0x80,0x0F,0x00,0x80,
   0x0F,0x00,0x00,0x07,0x00,0x80,0x0F,0x00,0x80,0x0F,0x00,0xC0,0x1D,0x00,0xE0,0x38,0x00,0xE0,0x38,0x00,
   0x70,0x70,0x00,0x38,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 120 LOWER CASE X
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x38,0xE0,0x00,0x70,0x70,0x00,0x70,0x70,0x00,0x70,0x70,0x00,0xE0,0x38,0x00,0xE0,0x38,0x00,0xE0,
   0x1D,0x00,0xC0,0x1D,0x00,0xC0,0x1D,0x00,0x80,0x0F,0x00,0x80,0x0F,0x00,0x80,0x0F,0x00,0x00,0x07,0x00,
   0x00,0x07,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0xC0,0x03,0x00,0xC0,0x01,0x00,0xC0,0x01,0x00,0xE0,0x00,0x00, // Code ASCII 121 LOWER CASE Y
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0xF8,0x1F,0x00,0xF8,0x1F,0x00,0x00,0x1C,0x00,0x00,0x0E,0x00,0x00,0x07,0x00,0x00,0x07,0x00,0x80,
   0x03,0x00,0xC0,0x03,0x00,0xC0,0x01,0x00,0xE0,0x00,0x00,0xE0,0x00,0x00,0x70,0x00,0x00,0x38,0x00,0x00,
   0xF8,0x1F,0x00,0xF8,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 122 LOWER CASE Z
   0x00,0x00,0x00,0x00,0x3C,0x00,0x00,0x3F,0x00,0x00,0x07,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,
   0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0xC0,0x01,0x00,0xE0,0x00,0x00,0x78,
   0x00,0x00,0x78,0x00,0x00,0xE0,0x00,0x00,0xC0,0x01,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,
   0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x00,0x07,0x00,0x00,0x3F,0x00,0x00,0x3C,0x00, // Code ASCII 123 {
   0x00,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,
   0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,
   0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,
   0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00, // Code ASCII 124 |
   0x00,0x00,0x00,0x78,0x00,0x00,0xF8,0x01,0x00,0xC0,0x01,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,
   0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x00,0x07,0x00,0x00,0x0E,0x00,0x00,
   0x3C,0x00,0x00,0x3C,0x00,0x00,0x0E,0x00,0x00,0x07,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,
   0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0x80,0x03,0x00,0xC0,0x01,0x00,0xF8,0x01,0x00,0x78,0x00,0x00, // Code ASCII 125 }
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x03,0x06,0xF0,0x07,0x06,0x30,0x0E,0x06,0x38,
   0x0C,0x03,0x18,0x1C,0x03,0x18,0xF8,0x01,0x18,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code ASCII 126 ~
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x03,0x06,0xF0,0x07,0x06,0x30,0x0E,0x06,0x38,
   0x0C,0x03,0x18,0x1C,0x03,0x18,0xF8,0x01,0x18,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 // Code ASCII 126 ~
  };

const uint8_t letter_font_start = 0;
const uint8_t letter_font_length_bytes = 81;
const uint8_t letter_font_width = 24;      // full bytes of pixels   8,16,24,32,40 etc
const uint8_t letter_font_height = 27;
const uint8_t Letter_Font_Spacing = 2;

//==============================================================
const uint8_t* FontPtr[95];

void Init_Font_System(void){

    uint16_t  i;

    // Build pointer table
    for (i = 0; i < 95; i++)
    {
        FontPtr[i] = &Letter_Font[i * letter_font_length_bytes];
    }
}

//==============================================================

#define black_Out         write_data_EpsonS1D13517(0x0000)
#define red_Out           write_data_EpsonS1D13517(0xF800)
#define orange_Out        write_data_EpsonS1D13517(0xFC20)
#define yellow_Out        write_data_EpsonS1D13517(0xFFC0)
#define green_Out         write_data_EpsonS1D13517(0x07E0)
#define blue_Out          write_data_EpsonS1D13517(0x0017)
#define purple_Out        write_data_EpsonS1D13517(0x8A99)
#define olive_Out         write_data_EpsonS1D13517(0x84A3)
#define white_Out         write_data_EpsonS1D13517(0xFFFF)
#define magenta_Out       write_data_EpsonS1D13517(0xF81A)
#define lime_Out          write_data_EpsonS1D13517(0xD7E0)
#define sienna_Out        write_data_EpsonS1D13517(0x9A85)
#define cyan_Out          write_data_EpsonS1D13517(0x07FF)
#define darkgoldenrod_Out write_data_EpsonS1D13517(0xB421)
#define aquamarine_Out    write_data_EpsonS1D13517(0x7FFA)
#define grey_Out          write_data_EpsonS1D13517(0x632C)
#define darkgrey_Out      write_data_EpsonS1D13517(0x2945)

//==============================================================

  const uint8_t black =  1;
  const uint8_t red =    2;
  const uint8_t orange = 3;
  const uint8_t yellow = 4;
  const uint8_t green =  5;
  const uint8_t blue =   6;
  const uint8_t purple = 7;
  const uint8_t olive =  8;
  const uint8_t white =  9;
  const uint8_t magenta = 10;
  const uint8_t lime =    11;
  const uint8_t sienna =  12;
  const uint8_t cyan =    13;
  const uint8_t darkgoldenrod = 14;
  const uint8_t aquamarine =    15;
  const uint8_t grey =          16;
  const uint8_t darkgrey =      17;

  //sbit TFT_RD  at LATC4_bit;
  //sbit TFT_WR  at LATC3_bit;
  //sbit TFT_RST_Direction at TRISD0_bit;   //RESET  Active low input
  //sbit TFT_RST at LATD0_Bit; //RESET  EPSON CHIP RESET    //EPSON CHIP RESET (WITH PULL-UP) NOT FITTED RESISTOR YET Active low input

  #define  SD_Card_Chip_Select LATA9_bit    //RA9
  #define  epson_CS LATG15_bit              //WIRED TO RD9 BUT THAT IS AN ADDRESS LINE SO BRIDGED TO RG15 //EPSON CHIP SELECT (WITH PULL-UP) NOT FITTED RESISTOR YET
  #define  Epson_HDC           LATG12_bit   //THE HD/C# INPUT PIN IS USED TO DISTINGUISH BETWEEN ADDRESS AND DATA LINKED ON PCB FROM PIC PIN 140 TO HD/C PIN
  #define  PMP_WRITE           LATC3_bit    //PMWR  WRITE  EBIWE/AN20/RPC3/PMWR/RC3 PIN 12
  #define  PMP_READ            LATC4_bit    //PMRD  READ   EBIOE/AN19/RPC4/PMRD/RC4 PIN 13 page 8 datasheet
  #define  RESET               LATD0_bit    //104 RPD0/RTCC/INT0/RD0

                                //    Register Read Procedure   PAGE 96    Register Read Procedure   PAGE 96     Register Read Procedure   PAGE 96

void write_command_EpsonS1D13517(uint8_t Command) {
  Epson_HDC = 0;                              //RS = 0 NOT DATA  D/C = 0    SET RS LINE LOW FOR COMMAND ON EPSON CHIP
  PMDIN = Command;
  while(PMMODE & 0x8000); //Busy bit
}

void write_data_EpsonS1D13517(uint16_t _data) {
  Epson_HDC = 1;                               //RS = 1 = DATA   D/C = 1    SET RS LINE HIGH FOR DATA  ON EPSON CHIP
  PMDIN = _data;
  while(PMMODE & 0x8000);                      //Busy bit
}

void Initialise_16Bit_PMP() {
                              // zero wait time is 8 ns strobe @224MHz   1=18.5ns  2=28ns
    PMAEN  = 0;               //5=55ns @224MHz and sram corrupt   3=36.5 to 37ns =2.240 MHz   4 = 46ns
    PMMODE = 0;
    //PMCONBits.DUALBUF = 1;  //DUAL BUFFER FOR IN AND OUT  NOT AVAILABLE ON ECM
    PMMODEbits.MODE = 2;      //Master 2     Slave =1
    PMMODEbits.WAITB = 0;     //WAITB<1:0>: Data Setup before a Read/Write Strobe Wait States bits(1) 11 = Data wait of 4 TPB; multiplexed address phase of 4 TPB  10 = Data wait of 3 TPB; multiplexed address phase of 3 TPB 01 = Data wait of 2 TPB; multiplexed address phase of 2 TPB 00 = Data wait of 1 TPB; multiplexed address phase of 1 TPB (default)
    PMMODEbits.WAITM = 1;     //1111 = Wait of 16 TPB --0001 = Wait of 2 TPB-- 0000 = Wait of 1 TPB (default)STROBE PULSE WIDTH
    PMMODEbits.WAITE = 0;     //bit 1-0WAITE<1:0>: Data Hold After Read/Write Strobe Wait States bits(1)

    PMMODEbits.MODE16 = 1;    // 1 = 16-bit mode: a read or write to the data register invokes a single 16-bit transfer   For read operations  11 = Wait of 3 TPB  00 = Wait of 0 TPB (default)
    PMCONbits.CSF = 0;        //Chip Select Bit
    PMCONbits.PTRDEN = 1;     //READ STROBE
    PMCONbits.PTWREN = 1;     //WRITE STROBE
    PMCONbits.PMPEN = 1;      //PMP ENABLE
    PMCONbits.ON = 1;
}

//==============================================================

void Init_MCU() {

    ANSELA = 0;
    ANSELB = 0;
    ANSELC = 0;
    ANSELD = 0;
    ANSELE = 0;
    ANSELF = 0;
    ANSELG = 0;
    ANSELH = 0;
    ANSELJ = 0;

    TRISA = 0;
    TRISB = 0;
    TRISC = 0;
    TRISD = 0;
    TRISE = 0;
    TRISF = 0;
    TRISG = 0;
    TRISH = 0;
    TRISJ = 0;
    TRISK = 0;

    TRISD14_Bit = 1;
    SDI3R  = 0b1011; // = RPD14      PAGE 251     RD14 = SDI3    SPI3  clock
    RPB10R = 0b0111; // = SDO3       PAGE 254     RB10 = SD03    SPI3  RB10 = SERIAL DATA OUT SPI3
    
    TRISBbits.TRISB8 = 1;  //SD CARD Detect

    PORTA=0;PORTB=0;PORTC=0;PORTD=0;PORTE=0;PORTF=0;PORTG=0; PORTH=0; PORTJ=0;  PORTK=0;

    JTAGEN_bit = 0;

    LATC13_Bit = 1;  //RC13 = LCD DISPLAY RESET //NOT CONNECTED
    LATH15_bit = 1;  //PIN31 LCD DISPLAY (DISP)  DISPLAY ENABLE
    LATD0_bit = 1;   //EPSON CHIP RESET (WITH PULL-UP) NOT FITTED RESISTOR YET
    LATG15_bit = 0;  //EPSON CHIP SELECT (WITH PULL-UP) RESISTOR NOT FITTED YET
}

//==============================================================

void Initialise_EpsonS1D13517_5_Inch(){

      //RESET               LATD0_bit    //104 RPD0/RTCC/INT0/RD0

      RESET = 0;
      Delay_ms(2);
      RESET = 1;                         //RESET  EPSON CHIP RESET    //EPSON CHIP RESET (WITH PULL-UP) NOT FITTED RESISTOR YET Active low input
      Delay_ms(100);
      epson_CS = 0;

      write_command_EpsonS1D13517(0x2A);
      write_data_EpsonS1D13517(0);         //Display Off

      write_command_EpsonS1D13517(0x68);   //9.4 Software Reset PAGE 51 bIT 7 = lcd, BIT 6 = PWM, BIT 5 = MEMORY CONTROLLER, BIT 4 = SDRAM CONTROLLER, BIT 3 = ALPHA BLEND, BIT ZERO IS POWER SAVE WHEN SET TO ZERO.
      write_data_EpsonS1D13517(0xF9);

      /////////////////////////////////////////PAGE 129 FOR EXAMPLES //////////////////////////////////////////////////////////

      write_command_EpsonS1D13517(0x04);
      write_data_EpsonS1D13517(0x17);      //PLLCLK = 1MHz (=24MHz/24=CLKI/PLL_D)         (REG[04h] bit 7 = PLL ENABLE   PAGE 49
      write_command_EpsonS1D13517(0x06);
      write_data_EpsonS1D13517(0x51);      //VCO = 142-180MHz
      write_command_EpsonS1D13517(0x08);   //PLL Divide Select REG 8
      write_data_EpsonS1D13517(0x01);      //PLLCLK is divided by 2
      write_command_EpsonS1D13517(0x0C);   //PLL N Divider
      write_data_EpsonS1D13517(0x59);      //Target Frequency = 90MHz; NN = 180; CLKI = 24MHz; PLL_D = 24:1
      write_command_EpsonS1D13517(0x12);   //Clock Source Select Register
      write_data_EpsonS1D13517(0x01);
      write_command_EpsonS1D13517(0x04);   //Enable PLL
      write_data_EpsonS1D13517(0x97);      //was 9D bit 7 enables the ppl
      write_command_EpsonS1D13517(0x0E);   //Spread Spectrum modulation enabled with default spread of +/-0.25ns
      write_data_EpsonS1D13517(0x3F);

      Delay_ms(1);

      write_command_EpsonS1D13517(0x12);
      write_data_EpsonS1D13517(0x81);     //was 81h 0x92 = 36 MHz 0x81 = 24MHz   82 = 30 mhz and 90 mhz on ram  81 = 30 mhz pixel clock

      //////////////PANEL SETTINGS BELOW ///// REGISTERS AUTO-INCREMENT ///////////// MODE REGISTERS ON PAGE 52 /////////////////////////////////////////////////////////

      write_command_EpsonS1D13517(0x14);   //LCD Panel Type Register
      write_data_EpsonS1D13517(4);         //INPUT IMAGE FORMAT PAGE 61
      write_command_EpsonS1D13517(0x16);   //Horizontal Display Width Register (HDISP) PAGE 44
      write_data_EpsonS1D13517(0x63);      //800 + 1 PIXELS WIDE DIVIDE BY 8 = 100  = 100  HEX=64
      write_command_EpsonS1D13517(0x18);   //Horizontal Non-Display Period Register (HNDP)
      write_data_EpsonS1D13517(0x7F);      //WAS 0X26 FAST 65 HZ 7F = 55.5 HZ
      write_command_EpsonS1D13517(0x1A);   //Vertical Display Height Register 0 (VDISP)
      write_data_EpsonS1D13517(0xDF);      //LOW BYTE OF DISPLAY HEIGHT
      write_command_EpsonS1D13517(0x1C);
      write_data_EpsonS1D13517(0x01);      //HIGH BYTE OF DISPLAY HEIGHT  1DF = 479
      write_command_EpsonS1D13517(0x1E);   //Vertical Non-Display Period Register (VNDP)   PAGE 62
      write_data_EpsonS1D13517(0x25);      //DECIMAL 15 GAVE 65 HZ   hex16 54 hz but 2ms pulse width 0X25 = 51 HZ AND NEARLY 3ms vertical pulse width
      write_command_EpsonS1D13517(0x20);   //PHS Pulse Width Register (HSW)
      write_data_EpsonS1D13517(0x27);      //was 0x0f fast 65 hz 0x27 = same
      write_command_EpsonS1D13517(0x22);   //PHS Pulse Start Position Register (HPS)
      write_data_EpsonS1D13517(0x78);      //was 0x10 fast 65 hz  0x78 = same 54 hz
      write_command_EpsonS1D13517(0x24);   //PVS Pulse Width Register (VSW)
      write_data_EpsonS1D13517(0x0A);      // 5 = 1ms   0X0A = STILL 2ms
      write_command_EpsonS1D13517(0x26);   //PVS Pulse Start Position Register (VPS)     PAGE 64
      write_data_EpsonS1D13517(10);        //was 4 LINES
      write_command_EpsonS1D13517(0x28);   //PCLK Polarity Register
      write_data_EpsonS1D13517(0x80);      //PCLK Falling edgeSDCLK

      //////////////SDRAM SETTINGS BELOW //////////////////////////////

      write_command_EpsonS1D13517(0x82);
      write_data_EpsonS1D13517(0x03);      //SDRAM memory size = 128MBits page 84
      write_command_EpsonS1D13517(0x8C);
      write_data_EpsonS1D13517(0xFF);      //SDRAM Refresh Rate
      write_command_EpsonS1D13517(0x8E);
      write_data_EpsonS1D13517(0x03);      //SDRAM Refresh Counter
      write_command_EpsonS1D13517(0x90);   //REG[90h] SDRAM Write Buffer Memory Size Register 0 PAGE 86  & 87
      write_data_EpsonS1D13517(71);        //VGA 1M BYTE 40h --  71 * 16384 = 1,163,264 BYTES PER BUFFER    11 C000h 800x480 = 384'000 times 3 = 1,152,000 BYTES PER PIXEL
                                                                      //16k = 2^14
      write_command_EpsonS1D13517(0x84);
      write_data_EpsonS1D13517(0x82);      //SDRAM refresh page 84

      write_command_EpsonS1D13517(0x68);
      write_data_EpsonS1D13517(0x01);      //Enable SDCLK page 51  When REG[68h] bit 0 = 1b, SDCLK is enabled and all internal clocks may be also enabled.

      //       NORMAL OPERATION HERE

     /*write_command_EpsonS1D13517(0x54);  //IF ALL SET TO 255 / 0xFF IT WILL MAKE white TRANSPARENT
      write_data_EpsonS1D13517(255);       //Transparency Key Color red Register
      write_command_EpsonS1D13517(0x56);
      write_data_EpsonS1D13517(255);       //Transparency Key Color green Register PAGE 74   white
      write_command_EpsonS1D13517(0x58);
      write_data_EpsonS1D13517(255);       //Transparency Key Color blue Register PAGE 75    white*/

     /*write_command_EpsonS1D13517(0x54);
      write_data_EpsonS1D13517(0);         //red Transparency black
      write_command_EpsonS1D13517(0x56);
      write_data_EpsonS1D13517(0);         //green Transparency black
      write_command_EpsonS1D13517(0x58);
      write_data_EpsonS1D13517(0);         //blue Transparency black*/

      //write_command_EpsonS1D13517(0xB2);   //REG[B2h] Interrupt Control Register   page 92
      //write_data_EpsonS1D13517(0b00010000);//INTERRUPTS   alpha blend
     // write_command_EpsonS1D13517(0xB6);
     // write_data_EpsonS1D13517(0x00);      //INTERRUPTS

    /*PIP 1 ADDRESS
      write_command_EpsonS1D13517(0x2C);   //page 66
      write_data_EpsonS1D13517(0x00);
      write_command_EpsonS1D13517(0x2E);   //page 66
      write_data_EpsonS1D13517(0x00);
      write_command_EpsonS1D13517(0x30);   //page 66
      write_data_EpsonS1D13517(0x28);      //BUFFER 2

      ///PIP 2 ADDRESS
      write_command_EpsonS1D13517(0x3E);   //page 66
      write_data_EpsonS1D13517(0x00);
      write_command_EpsonS1D13517(0x40);   //page 66
      write_data_EpsonS1D13517(0x00);
      write_command_EpsonS1D13517(0x42);   //page 66
      write_data_EpsonS1D13517(0x50);      //BUFFER 3 */

      write_command_EpsonS1D13517(0x6A);   //REG[6Ah] Non-Display Period Control / Status Register PAGE 79
      write_data_EpsonS1D13517(0);// 11b==int 00b = Horizontal Non-display Period   01b = Vertical Non-display Period 10b = Hdp Ord With Vdp 11b INT For Alpha Blend

      epson_CS = 1;
      Delay_ms(100); // <<< it does need this delay but not sure how long, MORE THAN ZERO

}

//==============================================================

static uint16_t background_Colour;

void Clear_Screen_S1D13517(uint16_t colour){

    uint8_t display_enable_bit = 0b0001;
    uint32_t i;
    const uint16_t number_of_Pixels = 384000;
    background_Colour = colour;

    epson_CS = 0;
    write_command_EpsonS1D13517(0x2A);                                         //REG[52h] Input Mode Register Page 73-- BITS 7,6,5,4 ARE INPUT BUFFER NUMBERS 1 TO 15 0b1111
    write_data_EpsonS1D13517(0b0000<<4 | display_enable_bit);                  //Bit 3 = Transparency Enable, Bit 2 = Reserved, Bit 1 = Mirror Display Enable, Bit zero = Rotation Enable

    write_command_EpsonS1D13517(0x5A);    //set window
    write_data_EpsonS1D13517(0);          //REG[5Ah] = 00h: Xstart = 0001
    write_data_EpsonS1D13517(0);          //REG[5Ch] = 00h, REG[5Eh] = 00h: Ystart = 0001
    write_data_EpsonS1D13517(0);          //REG[5Eh] = 00h: Ystart = 0001
    write_data_EpsonS1D13517(0xC6);       //REG[60h] = C6h: Xend = 800
    write_data_EpsonS1D13517(0x77);       //REG[62h] = 77h, REG[64h] = 03h: Yend = 480
    write_data_EpsonS1D13517(0x03);       //REG[64h] = 03h: Yend = 480

    switch(colour)  {

     case 1:     for(i=0;i<number_of_Pixels;i++){
                 black_Out;
                 background_Colour = 0x00;
                 } break;
     case 2:     for(i=0;i<number_of_Pixels;i++){
                 red_Out;
                 background_Colour = 0xF800;
                 } break;
     case 3:     for(i=0;i<number_of_Pixels;i++){
                 orange_Out;
                 background_Colour = 0xFC20;
                 } break;
     case 4:     for(i=0;i<number_of_Pixels;i++){
                 yellow_Out;
                 background_Colour = 0xFFC0;
                 } break;
     case 5:     for(i=0;i<number_of_Pixels;i++){
                 green_Out;
                 background_Colour = 0x07E0;
                 } break;
     case 6:     for(i=0;i<number_of_Pixels;i++){
                 blue_Out;
                 background_Colour = 0x0017;
                 } break;
     case 7:     for(i=0;i<number_of_Pixels;i++){
                 purple_Out;
                 background_Colour = 0X8A99;
                 } break;
     case 8:     for(i=0;i<number_of_Pixels;i++){
                 olive_Out;
                 background_Colour = 0x84A3;
                 } break;
     case 9:     for(i=0;i<number_of_Pixels;i++){
                 white_Out;
                 background_Colour = 0xFFFF;
                 } break;
     case 10:    for(i=0;i<number_of_Pixels;i++){
                 magenta_Out;
                 background_Colour = 0xF81A;
                 } break;
     case 11:    for(i=0;i<number_of_Pixels;i++){
                 lime_Out;
                 background_Colour = 0xD7E0;
                 } break;
     case 12:    for(i=0;i<number_of_Pixels;i++){
                 sienna_Out;
                 background_Colour = 0x9A85;
                 } break;
     case 13:    for(i=0;i<number_of_Pixels;i++){
                 cyan_Out;
                 background_Colour = 0x07FF;
                 } break;
     case 14:    for(i=0;i<number_of_Pixels;i++){
                 darkgoldenrod_Out;
                 background_Colour = 0xB421;
                 } break;
     case 15:    for(i=0;i<number_of_Pixels;i++){
                 aquamarine_Out;
                 background_Colour = 0x7FFA;
                 } break;
     case 16:    for(i=0;i<number_of_Pixels;i++){
                 grey_Out;
                 background_Colour = 0x632C;
                 } break;
     case 17:    for(i=0;i<number_of_Pixels;i++){
                 darkgrey_Out;
                 background_Colour = 0x2945;
                 } break;
     default:    for(i=0;i<number_of_Pixels;i++){
                 write_data_EpsonS1D13517(0xFFFF);
                 } break;
    }

   write_command_EpsonS1D13517(0x50);                                          //REG[50h] Display Control Register PAGE 72
   write_data_EpsonS1D13517(0x80);                                             //Bit 7 must be set to update display 0b10000000 = HEX 80 OR 128 DECIMAL
   epson_CS = 1;

}

//==============================================================

uint16_t Pixel;
void set_Pixel_Colour(uint16_t colour){

    switch(colour)  {

    case 1:     Pixel = 0x0000; //black
               break;
    case 2:     Pixel = 0xF800; //red
               break;
    case 3:     Pixel = 0xFC20; //orange
               break;
    case 4:     Pixel = 0xFFC0; //yellow
               break;
    case 5:     Pixel = 0x07E0; //green
               break;
    case 6:     Pixel = 0x017;  //blue
               break;
    case 7:     Pixel = 0X8A99; //purple
               break;
    case 8:     Pixel = 0x84A3; //olive
               break;
    case 9:     Pixel = 0xFFFF; //white
               break;
    case 10:    Pixel = 0xF81A; //magenta
               break;
    case 11:    Pixel = 0xD7E0; //lime
               break;
    case 12:    Pixel = 0x9A85; //sienna
               break;
    case 13:    Pixel = 0x07FF; //cyan
               break;
    case 14:    Pixel = 0xB421; //darkgoldenrod
               break;
    case 15:    Pixel = 0x7FFA; //aquamarine
               break;
    case 16:    Pixel = 0x4C0F; //aquamarine
               break;
    case 17:    Pixel = 0x632C; //grey
               break;
    case 18:    Pixel = 0x2945; //darkgrey
               break;
    default:    Pixel = 0xFFFF;
               break;
    }
}

//==============================================================

void Set_Display_Letters_S1D13517(uint16_t x_position, uint16_t y_position){

    uint16_t Set_Start_Column = 0x01 | x_position/4;
    uint16_t Set_Start_Row = 0x00 | y_position/4;
    uint16_t Set_End_Column = Set_Start_Column-2 + letter_font_width/4; //(bytes -1 bit) 8 pixels = 1 byte, 16 pixels = 2 bytes
    uint16_t Set_End_Row = Set_Start_Row + letter_font_height/4;
    epson_CS = 0;

    write_command_EpsonS1D13517(0x5A);              //X START REGISTER
    write_data_EpsonS1D13517(Set_Start_Column);     //X START
    write_data_EpsonS1D13517(Set_Start_Row);        //Y START REGISTER ZER0
    write_data_EpsonS1D13517(1);                    //Y START REGISTER 1
    write_data_EpsonS1D13517(Set_End_Column);       //X END POSITION
    write_data_EpsonS1D13517(Set_End_Row);          //Y END POSITION REGISTER ZER0
    write_data_EpsonS1D13517(1);                    //Y END POSITION REGISTER 1
    epson_CS = 1;
}

//==============================================================

void write_Character(const uint8_t* glyphPtr,  uint16_t x_position, uint16_t y_position, uint16_t colour){

    uint8_t x = 0;
    uint8_t dataout = 0;
    uint16_t i=1;
    uint16_t jj=0;
    set_Pixel_Colour(colour);
    Set_Display_Letters_S1D13517(x_position,y_position);
    epson_CS = 0;
    for (jj = 0; jj < letter_font_length_bytes; jj++){
    for(x=0; x<8; x++){
        dataout = glyphPtr[jj] &i;
      if(dataout){
        write_data_EpsonS1D13517(Pixel);
       }else  {write_data_EpsonS1D13517(background_Colour); }
        i=i<<1;
      if(i>128){
           i=1;}
     }
    }
    epson_CS = 1;
}

//==============================================================

void switchCharacter(uint8_t Value, uint16_t x, uint16_t y, uint16_t colour){

    const uint8_t* glyph;

    if (Value < 32 || Value > 126)
        return;

    glyph = FontPtr[Value - 32];

    write_Character(glyph, x, y, colour);
}

//==============================================================

void Write_Text(const unsigned char *text, unsigned int x, unsigned int y, unsigned char colour)
{
    unsigned int i = 0;

    while (text[i] != '\0') {
        switchCharacter(text[i], x + (i * Letter_Font_Width), y, colour);
        i++;
    }
}

//==============================================================

uint8_t   buf_BootSector[512];           // Raw boot sector buffer
uint8_t   buf_Data[512];                 // General-purpose sector buffer
uint8_t   buf_MBR[512];                  // Raw MBR buffer

uint32_t  currentCluster = 0;
uint16_t  currentSector  = 0;

uint16_t  dirX = 10;
uint16_t  dirY = 60;
uint8_t   dataBuffer[512];
uint32_t  data_area_start_Sector;   // first data sector (from boot sector)
uint16_t  displayDelay = 2000;   // 2 seconds between images

uint8_t   is_FAT16;                      // FAT16 flag
uint8_t   is_FAT32;                      // FAT32 flag

uint8_t   FAT16_Or_32;
uint32_t  fat_ClusterSize;               // Computed cluster size in bytes
uint32_t  first_FAT_Data_Start_Sector;           // Computed
uint32_t  first_FAT_Sector;
uint32_t  Root_Directory;
uint32_t  FAT1_Start_Sector;             // Computed

uint8_t   fileFound = 0;
uint32_t  file_startCluster = 0;
uint32_t  file_Size = 0;

uint8_t   longfilename_Buffer[260];      // holds the full long filename
uint16_t  longfilename_Length = 0;       // number of characters collected

uint32_t  sd_BootSectorLBA;              // 32-bit LBA of boot sector
uint32_t  partition_start_LBA = 0;
uint32_t  sd_TotalSectors;               // Card/partition geometry
uint16_t  sectorOffset   = 0;
uint8_t   sectorBuffer[512];
uint32_t  sector = 0;

uint16_t  bytes_per_Sector;            // From BPB
uint32_t  FAT_Size;                 // From BPB
uint8_t   number_of_FATs;              // From BPB
uint16_t  reserved_Sectors;           // From BPB

uint16_t  sectors_per_Cluster;         // From BPB
uint16_t  total_Sectors16;            // From BPB (legacy)
uint32_t  total_Sectors32;            // From BPB (modern)

uint8_t   Boot_Sector = 0;

uint32_t  Cluster_Size;
uint16_t  FAT_Start_Sector;
uint16_t  data_start_Sector;
uint8_t   Number_of_File_Allocation_Tables;
uint16_t  Number_of_Root_Directory_Entries;
uint32_t  Number_of_Sectors;
uint32_t  Number_Of_Hidden_Sectors;

uint16_t  Sectors_Per_FAT;



//==============================================================

void write_number(uint32_t value, uint16_t x, uint16_t y, uint16_t colour)
{
    static int previous_length = 0;   // How many digits were drawn last time

    uint8_t buffer[12];               // Temporary storage for digits (reverse order)
    int index = 0;
    int current_length;
    int draw_x;
    int i;

    // Extract digits from right to left
    do {
        buffer[index++] = '0' + (value % 10);   // Convert digit to ASCII
        value /= 10;                             // Remove that digit
    } while (value > 0);

    current_length = index;   // Number of digits this time

    // Draw digits from left to right by reading the buffer backwards
    draw_x = x;               // Preserve original x for blanking later
    while (index > 0) {
        index--;
        switchCharacter(buffer[index], draw_x, y, colour);
        draw_x += letter_font_width;
    }

    // If the new number has fewer digits, blank the leftovers
    if (current_length < previous_length) {
        int diff = previous_length - current_length;

        for (i = 0; i < diff; i++) {
            switchCharacter(' ', draw_x, y, background_colour);
            draw_x += letter_font_width;
        }
    }

    previous_length = current_length;   // Store for next call
}

//==============================================================

void Write_HexByte(uint8_t b, uint16_t x, uint16_t y, uint16_t colour){

    uint8_t hex[3];
    uint8_t hi;
    uint8_t lo;

    hi = (b >> 4) & 0x0F;
    lo = b & 0x0F;

    hex[0] = (hi < 10) ? ('0' + hi) : ('A' + (hi - 10));
    hex[1] = (lo < 10) ? ('0' + lo) : ('A' + (lo - 10));
    hex[2] = 0;

    write_text(hex, x, y, colour);
}

//==============================================================

void Set_Bus_Speeds(){

      /* unlock system for clock configuration */
    SYSKEY = 0x00000000;
    SYSKEY = 0xAA996655;
    SYSKEY = 0x556699AA;

    //000 = 1x divider  001 = 2x divider 010 = 3x divider  010 = 3x divider  011 = 4x divider  100 = 5x divider  101 = 6x divider  110 = 10x divider  111 = 12x divider
    // Peripheral Bus 1 cannot be turned off, so there's no need to turn it on
    PB1DIVbits.PBDIV = 1; // Peripheral Bus 1 Clock Divisor Control (PBCLK1 is SYSCLK divided by 2)

    // PB2DIV
    PB2DIVbits.ON = 1; // Peripheral Bus 2 Output Clock Enable (Output clock is enabled)
    PB2DIVbits.PBDIV = 1; // Peripheral Bus 2 Clock Divisor Control (PBCLK2 is SYSCLK divided by 2)  Peripheral Bus 2 Clock drives i2C, spi, PMP

    // PB3DIV
    PB3DIVbits.ON = 1; // Peripheral Bus 3 Output Clock Enable (Output clock is enabled)
    PB3DIVbits.PBDIV = 1; // Peripheral Bus 3 Clock Divisor Control (PBCLK3 is SYSCLK divided by 2)

    // PB4DIV
    PB4DIVbits.ON = 1; // Peripheral Bus 4 Output Clock Enable (Output clock is enabled)
    while (!PB4DIVbits.PBDIVRDY); // Wait until it is ready to write to
    PB4DIVbits.PBDIV = 1; // Peripheral Bus 4 Clock Divisor Control (PBCLK4 is SYSCLK divided by 1)        //four drives ports

    // PB5DIV
    PB5DIVbits.ON = 1; // Peripheral Bus 5 Output Clock Enable (Output clock is enabled)
    PB5DIVbits.PBDIV = 1; // Peripheral Bus 5 Clock Divisor Control (PBCLK5 is SYSCLK divided by 2)

    // PB7DIV
    PB7DIVbits.ON = 1; // Peripheral Bus 7 Output Clock Enable (Output clock is enabled)
    PB7DIVbits.PBDIV = 1; // Peripheral Bus 7 Clock Divisor Control (PBCLK7 is SYSCLK divided by 1)

    // PB8DIV
    PB8DIVbits.ON = 1; // Peripheral Bus 8 Output Clock Enable (Output clock is enabled)
    PB8DIVbits.PBDIV = 1; // Peripheral Bus 8 Clock Divisor Control (PBCLK8 is SYSCLK divided by 2)

    // PRECON - Set up prefetch
    PRECONbits.PFMSECEN = 0;  // Flash SEC Interrupt Enable (Do not generate an interrupt when the PFMSEC bit is set)
    PRECONbits.PREFEN = 0b11; // Predictive Prefetch Enable (Enable predictive prefetch for any address)  bit 5-4 PREFEN<1:0>: Predictive Prefetch Enable bits
    PRECONbits.PFMWS = 0b10;  // PFM Access Time Defined in Terms of SYSCLK Wait States (Two wait states)
    CFGCONbits.ECCCON = 3;
    SYSKEY = 0x00;
}

//==============================================================

void InitialiseSlowSPI(uint16_t Speed){
  SPI3_Init_Advanced(_SPI_MASTER, _SPI_8_BIT, Speed, _SPI_SS_DISABLE, _SPI_DATA_SAMPLE_MIDDLE, _SPI_CLK_IDLE_HIGH, _SPI_ACTIVE_2_IDLE);
}
void InitialiseFastSPI(uint8_t Speed){
  SPI3_Init_Advanced(_SPI_MASTER, _SPI_8_BIT, Speed, _SPI_SS_DISABLE, _SPI_DATA_SAMPLE_MIDDLE, _SPI_CLK_IDLE_HIGH, _SPI_ACTIVE_2_IDLE);
}

//==============================================================

                                           // DEFINITIONS FOR MMC/SD CARD COMMANDS
#define CMD0   (64 + 0)                    // Software Reset Command
#define CMD1   (64 + 1)                    // Initiate initialization process.
#define ACMD41 (64 + 41)                   // SEND_OP_COND (SDC)
#define CMD8   (64 + 8)                    // COMMAND  8  VERSION CHECK  For only SDC V2. Check voltage range.
#define CMD9   (64 + 9)                    // SEND_CSD  Read CSD register.
#define CMD10  (64 + 10)                   // SEND_CID  Read CID register.
#define CMD12  (64 + 12)                   // STOP_TRANSMISSION  Stop to read data.
#define ACMD13 (64 + 13)                   // SD_STATUS (SDC)
#define CMD16  (64 + 16)                   // SET SECTOR LENGTH OF BYTES YOU WANT TO READ Change R/W block size.
#define CMD17  (64 + 17)                   // READ SINGLE SECTOR
#define CMD18  (64 + 18)                   // READ MULTIPLE SECTORS UNTIL INTERRUPTED BY A 'STOP TRANSMISSION' COMMAND
#define CMD23  (64 + 23)                   // SET SECTOR COUNT / NUMBER OF BLOCKS TO READ FOR CMD18 & CMD25
#define ACMD23 (64 + 23)                   // SET_WRITE SECTOR ERASE COUNT (SDC) For only SDC. Define number of blocks to pre-erase with next multi-block write command.
#define CMD24  (64 + 24)                   // SET WRITE ADDRESS FOR SINGLE SECTOR
#define CMD25  (64 + 25)                   // SET FIRST WRITE ADDRESS FOR MULTIPLE SECTORS
#define CMD41  (64 + 41)                   // SEND_OP_COND (ACMD)
#define CMD55  (64 + 55)                   // APP_CMD  Leading command before ACMD command.
#define CMD58  (64 + 58)                   // READ OCR

volatile uint8_t MBR = 0;
void Initialise_SDCARD(){

    uint16_t x;
    uint16_t Counter = 0;
    uint8_t responseBuffer[5];
    uint8_t response1;
    uint8_t loop0;
    uint8_t loop8;
    uint8_t loop55;
    uint8_t loop58;
    uint8_t loop16;
    uint8_t read_again;
    uint8_t token;
    uint8_t Bit31;
    uint8_t Bit30;
    uint8_t Bits23_16;
    uint16_t Speed;
    uint16_t colour;

    Clear_Screen_S1D13517(darkgrey);
    write_text("Start of SD Card Initialisation", 12, 8, yellow);
    loop0:
    InitialiseSlowSPI(250);
    Delay_ms(1200);

    for(x = 0; x <10; x++){    // DUMMY CLOCKS  74 ARE REQUIRED.
     SPI3_Write(0xff);
    }

    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD0);          //Software Reset Command
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x95);          //0x95 Is Checksum For Software Reset

    Delay_ms(2);
    do {
    response1 = SPI3_Read(0xFF);
    Counter++;
    } while(response1 ==0xFF);

    SD_Card_Chip_Select = 1;
    SPI3_Write(0xFF);
    Delay_ms(2);

    if(response1 != 1 && response1 != 0){
    Clear_Screen_S1D13517(red);
    write_number(response1,30,120,white);
    write_text("CMD0 Error Response Value", 90, 180, white);  //debug
    }

    Delay_ms(20);           //TIME FOR SD CARD
    Counter = 0;

    write_text("Routine CMD0 Complete", 10, 42, orange);  //debug

    loop8:
    SPI3_Write(0xFF);
    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD8);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x01);
    SPI3_Write(0xAA);
    SPI3_Write(0x87);        //Checksum
    Delay_us(2);

    do {
    response1 = SPI3_Read(0xFF);
    Delay_us(2);
    } while(response1 != 0);

    Delay_ms(1);

    SD_Card_Chip_Select = 0;
    for(x = 0; x <4; x++){
    delay_ms(1);
    responseBuffer[x] = SPI3_Read(255);
    }

    SD_Card_Chip_Select = 1;
    SPI3_Write(0xFF);

    if(responseBuffer[0] !=0 && responseBuffer[1] !=0 && responseBuffer[2] !=1 && responseBuffer[3] !=170  ){
     Counter++;
    if(Counter >5){
       Clear_Screen_S1D13517(red);
       write_text("CMD8 ERROR SD CARD INIT",100,30,white);
       write_number(response1,30,70,blue);
       write_number(responseBuffer[0],30,100,blue);
       write_number(responseBuffer[1],30,130,blue);
       write_number(responseBuffer[2],30,160,blue);
       goto loop8;
     }
    }

    write_text("Routine CMD8 Complete", 10, 74, aquamarine);  //debug

    Counter = 0;
    loop55:

    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD55);  //     PAGE 59 OF SD CARD ASSOCIATION STATES THAT COMMAND 55 SHALL ALWAYS PRECEDE AMCD41
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x87);         // Checksum

    do {
    response1 = SPI3_Read(0xFF);
    counter++;
    } while(response1 !=1);

    SD_Card_Chip_Select = 1;
    SPI3_Write(0xFF);
    Delay_ms(2);
    Counter = 0;

    write_text("Routine CMD55 Complete", 10,106, magenta);  //debug

    Delay_ms(10);

    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD41);  //CMD41
    SPI3_Write(0x40);   //send 0x40... when card_version == 2 (SD v2). send 0x00... when card_version == 1 (SD v1).
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x87);   // Checksum was 0x87

    delay_us(2);
    do {
    response1 = SPI3_Read(0xFF);
    delay_us(2);
    } while(response1 ==0xFF);

    SD_Card_Chip_Select = 1;
    SPI3_Write(0xFF);
    Delay_ms(2);

    if(response1 !=0){

    Counter++;
    delay_us(500);

    if(Counter >10){
     Clear_Screen_S1D13517(red);
     write_text("CMD41 ERROR SD CARD INIT", 100, 30, white);
     write_text("SD CARD V1 MAYBE", 100, 60, white);
     write_number(response1,30,100,white);
     write_number(counter,  130,100,red);
    }
    goto loop55;
    }

    write_text("Routine CMD41 Complete", 10, 138, sienna);  //debug

    Counter = 0;
    loop58:

    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD58);       //OCR register (big-endian, MSB first)
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0xFF);        //Checksum

    delay_ms(2);
    do{
     response1 = SPI3_Read(0xFF);

    }while(response1 !=0xFF);

    for(x = 0; x <4; x++){

    delay_us(200);
    responseBuffer[x] = SPI3_Read(0xFF);
    }
    SD_Card_Chip_Select = 1;
    SPI3_Write(0xFF);
    Counter = 0;
    /*|------------------------------------------------------------------------------|
    |   31 = card power up complete and read                                       |
    |   30 = SDHC or SDXC                                                          |
    |   23 to 16 = if all bits set, voltage rand full from 2.7 volts to 3.6 volts  |
    |   15 - 8 voltage windows = 2 volts to 2.7 volts                              |
    |   bit 7 of last byte = voltage window of 1.7 volts to 2 volts                |
    |   bits 6 to zero = reserved                                                  |
    |                                                                              |
    |           192          255           128          65                         |
    |                                                                              |
    |         11000000     11111111      10000000      01000001                    |
    |______________________________________________________________________________|*/


    write_text("Routine CMD58 OCR Complete ", 10, 170, purple);

    Bit31 = responseBuffer[1] & 128;
    if(Bit31){

    write_text("Power-up Complete", 10, 234, green);

    }
    if( Bit31 ==0){

    write_text("POWER-UP FAIL", 10, 234, red);

    }

    Bit30 = responseBuffer[1] & 64;
    if(Bit30){

    write_text("SDHC Card", 10, 266, green);

    }
    if(Bit30 ==0){

    write_text("SDSC Card", 10, 266, red);

    }

    Bits23_16 = responseBuffer[2] & 0xFF;
    if(Bits23_16){

    write_text("Voltage Window 2.7 to 3.6", 10, 298, green);

    }

    if(Bit31 ==0){
    Counter++;
    Delay_ms(1);
    if(Counter >5){
     Clear_Screen_S1D13517(red);
      write_text("CMD58 ERROR POWER FAIL", 30, 50, white);
     Delay_ms(300);
    }
    goto loop58;
    }

    Delay_ms(600);

    loop16:
    speed = 10;
    InitialiseFastSPI(Speed); //<<<<<<<<<<<<<<<<<
    Delay_ms(10);
    Counter = 0;

    SPI3_Write(0xFF);
    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD16);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x02);
    SPI3_Write(0x00);
    SPI3_Write(0x87);      // Checksum

    delay_us(2);
    do{
     responseBuffer[5] = SPI3_Read(0xFF);
     delay_us(2);
    }while(responseBuffer[5] ==0xFF);
    SD_Card_Chip_Select = 1;
    SPI3_Write(0xFF);

    write_text("Routine CMD16 Complete", 10, 202, white);

    Counter = 0;
    read_again:

    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD17);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x00);
    SPI3_Write(0x87);      // Checksum
    Delay_us(2);

    do {
    responseBuffer[1] = SPI3_Read(0xFF);
    Delay_us(2);
    Counter++;
    } while(responseBuffer[1] ==0xFF);

    SD_Card_Chip_Select = 1;
    SPI3_Write(0xFF);
    Counter = 0;

    SD_Card_Chip_Select = 0;
    do {
    token = SPI3_Read(0xFF);
    Delay_us(40);
    Counter++;
    if(Counter >10)
    {
     goto read_again;
    }

    } while(token !=0xFE);

    for(x = 0; x <512; x++){
    asm nop; asm nop;
    buf_BootSector[x] = SPI3_Read(255);
    }

    for(x = 0; x < 2; x++)
    {
    responseBuffer[0] = SPI3_Read(255);
    }
    SD_Card_Chip_Select = 1;
    SPI3_Write(0xFF);

    Delay_ms(1000);

    if(buf_BootSector[54] ==70 && buf_BootSector[58] == 54 && buf_BootSector[510] ==0x55 && buf_BootSector[511] ==0xAA){
     Clear_Screen_S1D13517(sienna);
     colour = magenta;
     write_text("SD Card Initialised", 185, 30, cyan);
     switchCharacter(buf_BootSector[54], 300,100,colour);
     switchCharacter(buf_BootSector[55], 330,100,colour);
     switchCharacter(buf_BootSector[56], 360,100,colour);
     switchCharacter(buf_BootSector[57], 390,100,colour);
     switchCharacter(buf_BootSector[58], 420,100,colour);
     write_text("CMD17 Token =", 200, 160, yellow);
     write_text("Speed", 200, 200, green);
     Write_HexByte(token,550,160,green);
     write_number(Speed, 360, 200, green);
     Delay_ms(400);
    }

    if(buf_BootSector[54] != 70 && buf_BootSector[58] != 54 && buf_BootSector[0]==0 && buf_BootSector[2]==0){
     Clear_Screen_S1D13517(blue);
     write_text("POSSIBLE MBR FOUND NOT FAT16", 60, 30, white);
     Write_HexByte(buf_BootSector[0],30,70,red);
     Write_HexByte(buf_BootSector[1],30,100,red);
     Write_HexByte(buf_BootSector[2],30,130,red);
     Write_HexByte(buf_BootSector[510],30,160,red);
     Write_HexByte(buf_BootSector[511],90,160,red);
     MBR = 1;
     Delay_ms(600);
    }

    if(buf_BootSector[510] !=0x55 && buf_BootSector[511] !=0xAA){
     Clear_Screen_S1D13517(red);
     colour = white;
     Write_Text("BOOT SIGNATURE ERROR", 160, 30,white);
     Write_HexByte(buf_BootSector[0],30,60,colour);
     Write_HexByte(buf_BootSector[1],30,90,colour);
     Write_HexByte(buf_BootSector[2],30,120,colour);
     Write_HexByte(buf_BootSector[510],30,150,colour);
     Write_HexByte(buf_BootSector[511],120,150,colour);
     Write_Text("Speed currently  =", 30, 200,white);
     Write_Number(speed,450,200,white);
     Write_Text("Decreasing SPI Speed", 30, 240,white);
     Delay_ms(600);
     Speed+=4;
     Counter++;
     goto read_again;
     while(buf_BootSector[511] !=0xAA){
     }
    }

         //debug tool below
    /*write_number(responseBuffer[1],108,400,magenta);
    write_number(responseBuffer[2],190,350,white);
    write_number(responseBuffer[3],268,350,yellow);
    write_number(responseBuffer[4],346,350,blue);
    write_number(counter, 500, 400, white);
    //jump instructions, start of card
    Write_HexByte(buf_BootSector[0],30,30,red);
    Write_HexByte(buf_BootSector[1],30,60,red);
    Write_HexByte(buf_BootSector[2],30,90,red);
    //boot signature below
    Write_HexByte(buf_BootSector[510],30,290,red);
    Write_HexByte(buf_BootSector[511],30,330,red);
    //text letters below
    Switch_Character(buf_BootSector[54], 500,50,yellow);
    Switch_Character(buf_BootSector[55], 500,90,yellow);
    Switch_Character(buf_BootSector[56], 500,130,yellow);
    Switch_Character(buf_BootSector[57], 500,170,yellow);
    switch_Character(buf_BootSector[58], 500,210,yellow);*/

    Delay_ms(900);
}

//==============================================================

void Read_Sector(uint32_t address, uint8_t *buffer){

    uint16_t  ypos = 50;
    uint16_t  xpos = 20;
    uint16_t  x;
    uint16_t  Counter = 0;
    uint8_t loop1;
    uint8_t responseBuffer[4];

    loop1:
    SD_Card_Chip_Select = 0;
    SPI3_Write(CMD17);        //Command 17  Read Sector
    SPI3_Write(Address>>24);
    SPI3_Write(Address>>16);
    SPI3_Write(Address>>8);
    SPI3_Write(Address);
    SPI3_Write(0x87);
    SD_Card_Chip_Select = 1;
    SPI3_Write(0xFF);
    SD_Card_Chip_Select = 0;

    responseBuffer[0] = SPI3_Read(0xFF);   //Response 1   THIS WORKS BY ITSELF, IGNORE IT, IT'S USUALLY 0xFF

    do {
        responseBuffer[0] = SPI3_Read(0xFF);
        Delay_us(2);
    }   while (responseBuffer[0] !=0xFE);

    Counter = 0;
    if(responseBuffer[0] != 0xFE){
        Counter++;
        responseBuffer[0] = SPI3_Read(0xFF);
      if(Counter >100){
         Clear_Screen_S1D13517(red);

         write_text("CMD17 READ SECTOR ERROR", xpos , ypos, white);
         Delay_ms(100);
       }
       goto loop1;
     }

    for(x = 0; x <512; x++){

       buffer[x] = SPI3_Read(255);     //<<<<<<DATA BUFFER HERE
     }

    for(x = 0; x < 2; x++){

       responseBuffer[0] = SPI3_Read(255);
     }
      SD_Card_Chip_Select = 1;
       SPI3_Write(0xFF);
}

//============================================================

void Get_Boot_Information_FAT32() {

     uint16_t xpos_data = 550;
     uint16_t xpos_label = 12;
     uint16_t ypos_label = 30;
     uint16_t value;
     uint32_t cluster_for_rootDirectory;

    Clear_Screen_S1D13517(Black);
    write_text("Reading MBR Sector 0", xpos_label, 10, white);

    Read_Sector(0, buf_MBR);

    // --- Check MBR signature ---
    if (buf_MBR[510] != 0x55 || buf_MBR[511] != 0xAA) {
        write_text("INVALID MBR", 10, 90, red);
        while(1);
    }

    // --- FAT16 trap (sector 0 VBR) ---
    if (buf_MBR[0] == 0xEB ) {
        write_text("FAT16-at-sector0 TRAP", 10, 210, red);
        while(1);
    }

    // --- Decode LBA start ---
    partition_start_LBA =
           (uint32_t)buf_MBR[0x1C6]
        | ((uint32_t)buf_MBR[0x1C7] << 8)
        | ((uint32_t)buf_MBR[0x1C8] << 16)
        | ((uint32_t)buf_MBR[0x1C9] << 24);


    write_text("LBA address BPB", xpos_label, ypos_label+10, orange);
    Write_Number(partition_start_LBA, xpos_data, ypos_label+10, orange);
    Delay_ms(80);

    write_text("Reading Sector at LBA", xpos_label, ypos_label*2+10, white);
    Delay_ms(80);
    // --- Read boot sector ---
    Read_Sector(partition_start_LBA, buf_BootSector);

    sd_BootSectorLBA = partition_start_LBA;

    // --- Parse a couple of BPB fields ---
    bytes_per_Sector =
           buf_BootSector[0x0B]
        | (buf_BootSector[0x0C] << 8);

    Write_Number(bytes_per_Sector, xpos_data, ypos_label*3+10, yellow);
    write_text("Bytes Per Sector", xpos_label, ypos_label*3+10, yellow);
    Delay_ms(80);

    sectors_per_Cluster = buf_BootSector[0x0D];

    Write_Number(sectors_per_Cluster, xpos_data, ypos_label*4+10, green);
    write_text("Sectors per Cluster", xpos_label, ypos_label*4+10, green);
    Delay_ms(80);

    // ---------------------------------------------------------
    // BPB: Reserved sectors (offset 0x0E-0x0F)
    // ---------------------------------------------------------
    reserved_Sectors =
          buf_BootSector[0x0E]
        | (buf_BootSector[0x0F] << 8);

    Write_Number(reserved_Sectors, xpos_data, ypos_label*5+10, purple);
    write_text("Reserved Sectors", xpos_label, ypos_label*5+10, purple);
    Delay_ms(80);

    // ---------------------------------------------------------
    // BPB: Number of FATs (offset 0x10)
    // ---------------------------------------------------------
    number_of_FATs = buf_BootSector[0x10];

    Write_Number(number_of_FATs, xpos_data, ypos_label*6+10, olive);
    write_text("Number of FATs", xpos_label, ypos_label*6+10, olive);
    Delay_ms(80);

    // ---------------------------------------------------------
    // BPB: FAT size (FAT32 only) (offset 0x24-0x27)
    // ---------------------------------------------------------
    FAT_Size =
          (uint32_t)buf_BootSector[0x24]
        | ((uint32_t)buf_BootSector[0x25] << 8)
        | ((uint32_t)buf_BootSector[0x26] << 16)
        | ((uint32_t)buf_BootSector[0x27] << 24);

    Write_Number(FAT_Size, xpos_data, ypos_label*7+10, sienna);
    write_text("FAT Size", xpos_label, ypos_label*7+10, sienna);
    Delay_ms(80);

    // ---------------------------------------------------------
    // BPB: Total sectors (offset 0x20-0x23)
    // ---------------------------------------------------------
    total_Sectors32 =
          (uint32_t)buf_BootSector[0x20]
        | ((uint32_t)buf_BootSector[0x21] << 8)
        | ((uint32_t)buf_BootSector[0x22] << 16)
        | ((uint32_t)buf_BootSector[0x23] << 24);

    // (Optional display)
    // Write_Number(bpb_TotalSectors32, xpos_Start, fontHeight * 6, white);

    // ---------------------------------------------------------
    // BPB: Root directory cluster (offset 0x2C-0x2F)
    // ---------------------------------------------------------
    cluster_for_rootDirectory =
           (uint32_t)buf_BootSector[0x2C]
        | ((uint32_t)buf_BootSector[0x2D] << 8)
        | ((uint32_t)buf_BootSector[0x2E] << 16)
        | ((uint32_t)buf_BootSector[0x2F] << 24);

    Write_Number(cluster_for_rootDirectory, xpos_data, ypos_label*8+10, magenta);
    write_text("Root Directory Cluster", xpos_label, ypos_label*8+10, magenta);
    Delay_ms(80);

    // ---------------------------------------------------------
    // Compute FAT and data region locations
    // ---------------------------------------------------------
    first_FAT_Sector = sd_BootSectorLBA + reserved_Sectors;
    //first_FAT_Sector = reserved_Sectors;

    first_FAT_Data_Start_Sector =
          first_FAT_Sector
        + (number_of_FATs * FAT_Size);

    Write_Number(first_FAT_Sector, xpos_data, ypos_label*9+10, cyan);
    write_text("First_FAT_Sector", xpos_label, ypos_label*9+10, cyan);
    Delay_ms(80);

    Write_Number(first_FAT_Data_Start_Sector, xpos_data, ypos_label*10+10, olive);
    write_text("FAT_Data_Start_Sector", xpos_label, ypos_label*10+10, olive);
    Delay_ms(80);

    // ---------------------------------------------------------
    // Compute root directory sector from its cluster
    // ---------------------------------------------------------
    Root_Directory =
          first_FAT_Data_Start_Sector
        + ((Root_Directory) * sectors_per_Cluster);

    Write_Number(Root_Directory, xpos_data, ypos_label*11+10, red);
    write_text("Root Directory", xpos_label, ypos_label*11+10, red);

    write_text("fat size *2 + reserved for root", xpos_label, ypos_label*12+10, lime);
    write_text("File = root + cluster-2 * sec clu", xpos_label, ypos_label*13+10, lime);
    Delay_ms(2000);
    // while(1);
}

//==============================================================

void Get_Boot_Information(){

    uint16_t xpos_Start_Message = 216;
    uint16_t xpos_Numbers = 4;
    uint16_t font_Height = 2;
    uint16_t rootDirectorySectors;
    uint32_t Byte20;
    uint32_t Byte21;
    uint32_t Byte22;
    uint32_t Byte23;
    uint8_t x;

    if(MBR !=1){

    Read_Sector(0, buf_BootSector);

    Clear_Screen_S1D13517(darkgrey);

    Bytes_Per_Sector = buf_BootSector[0x0B] + (buf_BootSector[0x0C]<<8);
    write_number(Bytes_Per_Sector, xpos_Numbers, font_Height, darkgoldenrod);
    write_text("= Bytes Per Sector", xpos_Start_Message, font_Height *1 + 4, darkgoldenrod);

    font_Height = 32;

    sectors_Per_Cluster = buf_BootSector[0x0D];
    write_number(sectors_Per_Cluster, xpos_Numbers, font_Height, red);
    write_text("= Sectors Per Cluster", xpos_Start_Message, font_Height + 4, red);

    reserved_Sectors = buf_BootSector[0x0E] + (buf_BootSector[0x0F]<<8);  //Reserved Sector
    write_number(reserved_Sectors, xpos_Numbers, font_Height *2, yellow);
    write_text("= Reserved Sectors", xpos_Start_Message, font_Height *2 + 4, yellow);

    Number_of_File_Allocation_Tables = buf_BootSector[0x10];
    write_number(Number_of_File_Allocation_Tables, xpos_Numbers, font_Height *3, cyan);
    write_text("= Number Of FAT Tables", xpos_Start_Message, font_Height *3 + 4, cyan);

    Number_of_Root_Directory_Entries = buf_BootSector[0x11] + (buf_BootSector[0x12]<<8);
    write_number(Number_of_Root_Directory_Entries, xpos_Numbers, font_Height *4, white);
    write_text("= Number Of Root Entries", xpos_Start_Message, font_Height *4 + 4, white);

    Sectors_Per_FAT = buf_BootSector[0x16] + (buf_BootSector[0x17]<<8);
    write_number(Sectors_Per_FAT, xpos_Numbers, font_Height *5, green);
    write_text("= Sectors Per Fat", xpos_Start_Message, font_Height *5 + 4, green);

    Byte23 =   buf_BootSector[0x23]<<24;
    Byte22 =   buf_BootSector[0x22]<<16;
    Byte21 =   buf_BootSector[0x21]<<8;
    Byte20 =   buf_BootSector[0x20];

    Number_of_Sectors =  Byte23 + Byte22 + Byte21 + Byte20;
    write_number(Number_of_Sectors, xpos_Numbers, font_Height *6, purple);
    write_text("= Total Sectors", xpos_Start_Message, font_Height *6 + 4, purple);

    FAT_Start_Sector = Boot_Sector + reserved_Sectors;
    write_number(FAT_Start_Sector, xpos_Numbers, font_Height *7, red);
    write_text("= Fat Start = Reserved", xpos_Start_Message, font_Height *7 + 4, red);

    Root_Directory = reserved_Sectors + (Sectors_Per_FAT * Number_of_File_Allocation_Tables); //i.e. 6  +  (233 * 2 )
    write_number(Root_Directory, xpos_Numbers, font_Height *8 , magenta);
    write_text("= Root Directory", xpos_Start_Message, font_Height *8 + 4, magenta);

    rootDirectorySectors = (Number_of_Root_Directory_Entries * 32) / Bytes_Per_Sector;
    data_start_Sector = reserved_Sectors + (Number_of_File_Allocation_Tables * Sectors_Per_FAT)+ rootDirectorySectors;
    Delay_ms(3000);

    xpos_Start_Message = 188;
    Clear_Screen_S1D13517(darkgrey);

    for (x=0; x<17 ;x++){

         write_number(data_start_Sector, xpos_Numbers+4, 8 , x);
         write_text("= Data Start Sector", xpos_Start_Message, 8 + 4, x+1);
         delay_ms(12);
    }
    write_text("Cluster 2  =504 + 64 * 0", xpos_Start_Message,  font_Height *2 + 4,  orange);
    write_text("Cluster 3  =504 + 64 * 1", xpos_Start_Message,  font_Height *3 + 4,  yellow);
    write_text("Cluster 4  =504 + 64 * 2", xpos_Start_Message,  font_Height *4 + 4,  green);
    write_text("Cluster 5  =504 + 64 * 3", xpos_Start_Message,  font_Height *5 + 4,  aquamarine);
    write_text("Cluster 6  =504 + 64 * 4", xpos_Start_Message,  font_Height *6 + 4,  darkgoldenrod);
    write_text("Cluster 7  =504 + 64 * 5", xpos_Start_Message,  font_Height *7 + 4,  red);
    write_text("Cluster 8  =504 + 64 * 6", xpos_Start_Message,  font_Height *8 + 4,  sienna);
    write_text("Cluster 9  =504 + 64 * 7", xpos_Start_Message,  font_Height *9 + 4,  white);
    write_text("Cluster 10 =504 + 64 * 8", xpos_Start_Message,  font_Height *10 + 4, magenta);
    write_text("Cluster 11 =504 + 64 * 9", xpos_Start_Message,  font_Height *11 + 4, lime);
    write_text("Cluster 12 =504 + 64 * 10", xpos_Start_Message, font_Height *12 + 4, orange);
    write_text("Cluster 13 =504 + 64 * 11", xpos_Start_Message, font_Height *13 + 4, green);

    write_number(504+ (64*0), xpos_Numbers,  font_Height *2 ,  orange);
    write_number(504+ (64*1), xpos_Numbers,  font_Height *3 ,  yellow);
    write_number(504+ (64*2), xpos_Numbers,  font_Height *4 ,  green);
    write_number(504+ (64*3), xpos_Numbers,  font_Height *5 ,  cyan);
    write_number(504+ (64*4), xpos_Numbers,  font_Height *6 ,  darkgoldenrod);
    write_number(504+ (64*5), xpos_Numbers,  font_Height *7 ,  red);
    write_number(504+ (64*6), xpos_Numbers,  font_Height *8 ,  sienna);
    write_number(504+ (64*7), xpos_Numbers,  font_Height *9 ,  white);
    write_number(504+ (64*8), xpos_Numbers,  font_Height *10 , magenta);
    write_number(504+ (64*9), xpos_Numbers,  font_Height *11 , lime);
    write_number(504+ (64*10), xpos_Numbers, font_Height *12 , orange);
    write_number(504+ (64*11), xpos_Numbers, font_Height *13 , green);

    Delay_ms(500);
    } else  Get_Boot_Information_FAT32();

}

//==============================================================

void Show_Epson_Colour_Bars(){

    uint8_t Memory_buffer_Number = 0;
    //TRISE8_bit = 1;   //Tear Link For Display
    //INT1R = 1101;     // = RPE8  INTERRUPT FOR BLANKING PERIOD & OR ALPHA BLEND

    epson_CS = 0;
    write_command_EpsonS1D13517(0x2A);    //Display Mode Register PAGE 64 & 66
    write_data_EpsonS1D13517(0b00001111); // PAGE 66  COLOUR BAR   PAGE 123
    write_command_EpsonS1D13517(0x50);    // REG[50h] Display Control Register PAGE 72
    write_data_EpsonS1D13517(0x80);       //Bit 7 Must Be Set To Update Display
    epson_CS = 1;
    // The Test Color Bar Display Does Not Use The Sdram Memory And Is Selected When Reg[2Ah] Bits 3-1 = 111b
    Delay_ms(3000);

    epson_CS = 0;
    write_command_EpsonS1D13517(0x2A);    //Display Mode Register PAGE 64 & 66
    write_data_EpsonS1D13517(Memory_Buffer_Number<<4 | 0b0001); //Enable the display   Single buffer display (default) page 65
    write_command_EpsonS1D13517(0x50);    // REG[50h] Display Control Register PAGE 72
    write_data_EpsonS1D13517(0x80);       //Bit 7 Must Be Set To Update Display
    epson_CS = 1;
}

//==============================================================

void font_test(){

     Clear_Screen_S1D13517(sienna);

     write_text("ABCDEFGHIJKLMNOPQRSTUVWXYZ",4,10,yellow);
     write_text("abcdefghijklmnopqrstuvwxyz",4,100,white);
     write_text(" ! # $ % & ' ( ) * + , - . / : ",4,200,white);
     write_text(" ; < = > ? [ \ ] ^ _ ' { | } ~ ",4,300,white);

     Delay_ms(2000);
}

//==============================================================

void main() {

     uint16_t i=0;
     uint8_t SD_CARD_Detect;

     Initialise_16Bit_PMP();

     Init_MCU();

     Set_Bus_Speeds();

     Initialise_EpsonS1D13517_5_Inch();

     Init_Font_System();

     //Show_Epson_Colour_Bars();


     Clear_Screen_S1D13517(sienna);

     while(RB8_bit){
     LATA1_bit = RB8_bit;
     Clear_Screen_S1D13517(red);
     write_text("NO SD CARD FOUND", 160,30,white);
     Delay_ms(500);
     }

     Initialise_SDCARD();

     Get_Boot_Information();

     font_test();




}